unit Graphics;interface	uses		QDOffscreen, Globals;{----------------------------}	procedure InitGraphics;	procedure DrawPac;	procedure DrawBackdrop;	procedure DrawScreen;{----------------------------}implementation{----------------------------}	procedure BuildOffWorld (sizeOfDoc: Rect);		var			oldPerm: boolean;			currDevice: GDHandle;			currPort: GWorldPtr;			erry: OSErr;	begin		GetGWorld(currPort, currDevice);		erry := NewGWorld(gameWindow.offGWorld, 16, sizeOfDoc, nil, nil, GWorldFlags(0));		SetGWorld(gameWindow.offGWorld, nil);		if (LockPixels(gameWindow.offGWorld^.portPixMap)) then			begin				EraseRect(gameWindow.offGWorld^.portRect);				UnlockPixels(gameWindow.offGWorld^.portPixMap);			end;		SetGWorld(currPort, currDevice);	end;{----------------------------}	procedure InitPict_Backdrop;		var			resourceRect: Rect;	begin		with backgroundPict do			begin				if gColorQdAvailable then					if gameMenus.windowSelection = 1 then						pictH := GetPicture(backdropSmallBwPictID)					else if gameMenus.windowSelection = 2 then						pictH := GetPicture(backdropMediumColorPictID)					else if gameMenus.windowSelection = 3 then						pictH := GetPicture(backdropLargeColorPictID)					else						exit(InitPict_Backdrop)				else					pictH := GetPicture(backdropSmallBwPictID);				resourceRect := backgroundPict.pictH^^.picFrame;				pictWidth := resourceRect.right - resourceRect.left;				pictHeight := resourceRect.bottom - resourceRect.top;				pictLeft := round((gameWindow.width - pictWidth) / 2);				pictTop := round((gameWindow.height - pictHeight) / 2);				SetRect(pictRect, pictLeft, pictTop, pictLeft + pictWidth, pictTop + pictHeight);			end;	end;{----------------------------}	procedure InitPict_Pac;		var			resourceRect: Rect;	begin		with pacmanPict do			begin				case gameMenus.windowSelection of					1: 						begin{ small }							pictH := GetPicture(smallPacman_lt1);							pictLeft := 248;							pictTop := 220;						end;					2: 						begin{ medium }							pictH := GetPicture(mediumPacman_lt1);							pictLeft := 308;							pictTop := 319;						end;					3: 						begin{ large }							pictH := GetPicture(largePacman_lt1);							pictLeft := 492;							pictTop := 526;						end;				end;				increment := (-5);				resourceRect := pictH^^.picFrame;				pictSize := resourceRect.right - resourceRect.left;				SetRect(pictRect, pictLeft, pictTop, pictLeft + pictSize, pictTop + pictSize);			end;	end;{----------------------------}	procedure InitGraphics;	begin		BuildOffWorld(gameWindow.windowPtr^.portRect);		InitPict_Backdrop;		InitPict_Pac;	end;{----------------------------}	procedure DrawStats;		var			ticksAsString: Str255;	begin		PenPat(white);		MoveTo(10, 40);		TextMode(srcXor);		NumToString(gameGlobals.avgDrawCycles, ticksAsString);		DrawString(concat('ticks/draw:', ticksAsString));	end;{----------------------------}	procedure DrawPac;	begin		with pacmanPict do			begin{ lets move it somewheres else, shallll we.... }				pictLeft := pictRect.left + increment;				if pictLeft < 200 then					begin						pictLeft := 200;						increment := increment * (-1);					end;				if pictLeft > 400 then					begin						pictLeft := 400;						increment := increment * (-1);					end;				SetRect(pictRect, pictLeft, pictTop, pictLeft + pictSize, pictTop + pictSize);				DrawPicture(pictH, pictRect);			end;	end;{----------------------------}	procedure DrawBackdrop;	begin		with backgroundPict do			begin				FillRect(pictRect, white);				DrawPicture(pictH, pictRect);			end;	end;{----------------------------}	procedure DrawScreen;		var			offscreenPixMap, windowPixMap: PixMap;			windowBitMap: BitMap;			screenRect: Rect;			currPort: GWorldPtr;			currDevice: GDHandle;	begin		GetGWorld(currPort, currDevice);		SetGWorld(gameWindow.offGWorld, nil);		if (LockPixels(GetGWorldPixMap(gameWindow.offGWorld))) then			begin{ draw all game elements onto offscreen PixMap }{ background color }				FillRect(gameWindow.offGWorld^.portRect, black);				DrawBackdrop;				DrawPac;				DrawStats;				UnlockPixels(GetGWorldPixMap(gameWindow.offGWorld));			end;		SetGWorld(currPort, currDevice);{ offscreenPixMap fully drawn, now copy it to the gameWindow PixMap }		offscreenPixMap := GetGWorldPixMap(gameWindow.offGWorld)^^;		screenRect := gameWindow.windowPtr^.portRect;		if gameMenus.windowSelection = 1 then			begin				windowBitMap := gameWindow.windowPtr^.portBits;				CopyBits(BitMapPtr(@offscreenPixMap)^, windowBitMap, screenRect, screenRect, srcCopy, nil);			end		else if gameMenus.windowSelection = 2 then			begin				windowPixMap := gameWindow.cWindowPtr^.portPixMap^^;				CopyBits(BitMapPtr(@offscreenPixMap)^, BitMapPtr(@windowPixMap)^, screenRect, screenRect, srcCopy, nil);			end		else if gameMenus.windowSelection = 3 then			begin				windowPixMap := gameWindow.cWindowPtr^.portPixMap^^;				CopyBits(BitMapPtr(@offscreenPixMap)^, BitMapPtr(@windowPixMap)^, screenRect, screenRect, srcCopy, nil);			end;		gameGlobals.lastDrawTick := TickCount;		gameGlobals.drawCycles := gameGlobals.drawCycles + 1;	end;{----------------------------}end.